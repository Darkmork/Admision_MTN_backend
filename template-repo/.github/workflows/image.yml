name: Build & Push Container Image
on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      push_latest:
        description: 'Push latest tag'
        required: false
        default: 'true'
        type: boolean

env:
  REGISTRY: ghcr.io
  # Alternative for ECR: REGISTRY: ${{ vars.ECR_REGISTRY || '123456789012.dkr.ecr.us-east-1.amazonaws.com' }}
  IMAGE_NAME: ${{ github.repository }}
  TZ: America/Santiago

jobs:
  build:
    name: Build Container Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write  # Para Cosign OIDC
      security-events: write  # Para SARIF upload
      
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
      version: ${{ steps.meta.outputs.version }}
      
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=host

      - name: Setup QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      # Autenticaci√≥n a GHCR
      - name: Login to GitHub Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Autenticaci√≥n a ECR (comentado por defecto, habilitar si se usa ECR)
      # - name: Configure AWS credentials
      #   if: github.event_name != 'pull_request' && env.REGISTRY == 'ecr'
      #   uses: aws-actions/configure-aws-credentials@v4
      #   with:
      #     role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
      #     aws-region: ${{ vars.AWS_REGION }}
      #     role-session-name: GitHubActions-${{ github.run_id }}

      # - name: Login to Amazon ECR
      #   if: github.event_name != 'pull_request' && env.REGISTRY == 'ecr'
      #   uses: aws-actions/amazon-ecr-login@v2

      - name: Extract Image Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=raw,value=latest,enable={{is_default_branch}}
          labels: |
            org.opencontainers.image.title={{ github.repository }}
            org.opencontainers.image.description=MTN Microservice
            org.opencontainers.image.url={{github.server_url}}/{{github.repository}}
            org.opencontainers.image.source={{github.server_url}}/{{github.repository}}
            org.opencontainers.image.version={{version}}
            org.opencontainers.image.created={{date 'YYYY-MM-DDTHH:mm:ssZ'}}
            org.opencontainers.image.revision={{sha}}
            org.opencontainers.image.licenses=MIT
            build.url=${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            build.commit.sha=${{ github.sha }}
            build.branch=${{ github.ref_name }}

      - name: Build and Push Docker Image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDTIME=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VERSION=${{ steps.meta.outputs.version }}
            REVISION=${{ github.sha }}

      - name: Set Image Output
        id: image
        run: echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.version }}" >> $GITHUB_OUTPUT

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name != 'pull_request'
    permissions:
      security-events: write
      contents: read
      
    steps:
      - name: Run Trivy Vulnerability Scanner
        uses: aquasecurity/trivy-action@0.20.0
        with:
          image-ref: ${{ needs.build.outputs.image }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'  # Fallar si hay vulnerabilidades cr√≠ticas o altas

      - name: Upload Trivy Scan Results
        if: always()
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Generate Vulnerability Report
        if: always()
        uses: aquasecurity/trivy-action@0.20.0
        with:
          image-ref: ${{ needs.build.outputs.image }}
          format: 'json'
          output: 'vulnerability-report.json'

      - name: Upload Vulnerability Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: vulnerability-report-${{ github.sha }}
          path: vulnerability-report.json

  sbom:
    name: Generate SBOM
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name != 'pull_request'
    permissions:
      contents: read
      packages: read
      
    steps:
      - name: Generate SBOM with Syft
        uses: anchore/sbom-action@v0
        with:
          image: ${{ needs.build.outputs.image }}
          format: cyclonedx-json
          output-file: sbom-cyclonedx.json

      - name: Generate SBOM with Syft (SPDX)
        uses: anchore/sbom-action@v0
        with:
          image: ${{ needs.build.outputs.image }}
          format: spdx-json
          output-file: sbom-spdx.json

      - name: Upload SBOM Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ github.sha }}
          path: |
            sbom-cyclonedx.json
            sbom-spdx.json

      - name: Attest SBOM
        uses: actions/attest-sbom@v1
        if: github.ref == 'refs/heads/main'
        with:
          subject-path: sbom-cyclonedx.json
          subject-name: ${{ needs.build.outputs.image }}

  sign:
    name: Sign Container Image
    runs-on: ubuntu-latest
    needs: [build, security-scan, sbom]
    if: github.event_name != 'pull_request' && needs.security-scan.result == 'success'
    permissions:
      contents: read
      packages: write
      id-token: write
      
    steps:
      - name: Install Cosign
        uses: sigstore/cosign-installer@v3
        with:
          cosign-release: 'v2.2.3'

      - name: Sign Container Image
        env:
          DIGEST: ${{ needs.build.outputs.digest }}
        run: |
          cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${DIGEST}

      - name: Attest Container Image
        env:
          DIGEST: ${{ needs.build.outputs.digest }}
        run: |
          cosign attest --yes --type vuln \
            --predicate vulnerability-report.json \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${DIGEST} || true

  scan-runtime:
    name: Runtime Security Scan
    runs-on: ubuntu-latest
    needs: [build, sign]
    if: github.event_name != 'pull_request' && needs.sign.result == 'success'
    
    steps:
      - name: Test Container Runtime
        run: |
          # Ejecutar contenedor para verificar que arranca correctamente
          docker pull ${{ needs.build.outputs.image }}
          
          # Ejecutar con usuario no-root
          docker run --rm --user 1000:1000 \
            --name runtime-test \
            ${{ needs.build.outputs.image }} \
            java -version

          # Verificar health endpoint (si existe)
          docker run -d --name health-test \
            -p 8080:8080 \
            ${{ needs.build.outputs.image }}
          
          # Esperar que el servicio est√© listo
          timeout 60s bash -c 'until docker exec health-test curl -f http://localhost:8080/actuator/health > /dev/null 2>&1; do sleep 2; done'
          
          docker stop health-test
          docker rm health-test

  update-deployment:
    name: Update Deployment Manifests
    runs-on: ubuntu-latest
    needs: [build, sign]
    if: github.ref == 'refs/heads/main' && needs.sign.result == 'success'
    permissions:
      contents: write
      
    steps:
      - name: Checkout Deployment Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/mtn-k8s-manifests
          token: ${{ secrets.DEPLOY_REPO_TOKEN }}
          path: k8s-manifests

      - name: Update Image Tag in Dev Environment
        run: |
          cd k8s-manifests
          
          SERVICE_NAME=$(basename ${{ github.repository }})
          NEW_TAG="${{ needs.build.outputs.version }}"
          
          # Actualizar values-dev.yaml
          sed -i "s|tag:.*|tag: \"${NEW_TAG}\"|g" \
            ${SERVICE_NAME}/helm/${SERVICE_NAME}/values-dev.yaml
          
          # Actualizar metadatos de build
          sed -i "s|sha:.*|sha: \"${{ github.sha }}\"|g" \
            ${SERVICE_NAME}/helm/${SERVICE_NAME}/values-dev.yaml
          sed -i "s|url:.*|url: \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"|g" \
            ${SERVICE_NAME}/helm/${SERVICE_NAME}/values-dev.yaml

      - name: Commit and Push Changes
        run: |
          cd k8s-manifests
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          if git diff --quiet; then
            echo "No changes to commit"
          else
            git add .
            git commit -m "chore: update $(basename ${{ github.repository }}) to ${{ needs.build.outputs.version }}
            
            Image: ${{ needs.build.outputs.image }}
            Commit: ${{ github.sha }}
            Build: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            git push
          fi

  notify-success:
    name: Notify Success
    runs-on: ubuntu-latest
    needs: [build, security-scan, sbom, sign, scan-runtime]
    if: success() && github.ref == 'refs/heads/main'
    
    steps:
      - name: Slack Success Notification
        if: env.SLACK_WEBHOOK_URL != ''
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#deployments'
          username: 'Docker Build Bot'
          icon_emoji: ':docker:'
          text: |
            ‚úÖ *Container image built successfully*
            
            *Repository:* ${{ github.repository }}
            *Image:* `${{ needs.build.outputs.image }}`
            *Digest:* `${{ needs.build.outputs.digest }}`
            *Size:* $(docker manifest inspect ${{ needs.build.outputs.image }} --verbose | jq -r '.manifests[0].platform.size // "unknown"')
            
            üîí Image signed with Cosign
            üìã SBOM generated (CycloneDX + SPDX)
            üõ°Ô∏è Security scan passed
            
            <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Build>
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}